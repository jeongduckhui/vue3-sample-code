
const [value, setValue] = useState({
  id: '',
  name: '',
});

const handleMultiSelectChange = (selectedArr) => {
  setValue(syncCommaObject(selectedArr));
};





/**
 * @param selectedArr string[]  // ë©€í‹°ì…€ë ‰íŠ¸ í˜„ìž¬ ì„ íƒê°’ ì „ì²´
 * @returns { id: string, name: string }
 */
const syncCommaObject = (selectedArr = []) => {
  const unique = Array.from(
    new Set(
      selectedArr
        .map(v => v?.trim())
        .filter(Boolean)
    )
  );

  const joined = unique.join(', ');

  return {
    id: joined,
    name: joined,
  };
};






const addValue = (current, newVal) => {
  const set = new Set(
    current
      .split(',')
      .map(v => v.trim())
      .filter(Boolean)
  );

  set.add(newVal); // ì¤‘ë³µì´ë©´ ìžë™ ë¬´ì‹œ

  return Array.from(set).join(', ');
};


const addValues = (current, incomingStr) => {
  const set = new Set(
    current
      .split(',')
      .map(v => v.trim())
      .filter(Boolean)
  );

  incomingStr
    .split(',')
    .map(v => v.trim())
    .filter(Boolean)
    .forEach(v => set.add(v));

  return Array.from(set).join(', ');
};



setValue(prev => ({
  id: addValue(prev.id, incoming.id),
  name: addValue(prev.name, incoming.name),
}));



const toSet = (idStr) =>
  new Set(
    idStr
      .split(',')
      .map(v => v.trim())
      .filter(Boolean)
  );



setSelected(prev => {
  const incomingSet = toSet(incoming.id);

  // ê¸°ì¡´ ë°ì´í„° ì¤‘ í•˜ë‚˜ë¼ë„ ê²¹ì¹˜ë©´ "ì¤‘ë³µ"
  const isDuplicate = prev.some(item => {
    const itemSet = toSet(item.id);
    return [...incomingSet].some(v => itemSet.has(v));
  });

  if (isDuplicate) {
    return prev; // ðŸ”¥ ì¤‘ë³µì´ë©´ ë¬´ì‹œ
  }

  return [...prev, incoming];
});








setSelected(prev => {
  const incomingSet = toSet(incoming.id);

  let merged = false;

  const next = prev.map(item => {
    const itemSet = toSet(item.id);

    const hasOverlap = [...incomingSet].some(v => itemSet.has(v));
    if (!hasOverlap) return item;

    merged = true;

    const union = new Set([...itemSet, ...incomingSet]);
    const mergedStr = Array.from(union).join(', ');

    return {
      id: mergedStr,
      name: mergedStr,
    };
  });

  if (!merged) {
    next.push(incoming);
  }

  return next;
});


