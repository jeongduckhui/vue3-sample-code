
const toSet = (idStr) =>
  new Set(
    idStr
      .split(',')
      .map(v => v.trim())
      .filter(Boolean)
  );



setSelected(prev => {
  const incomingSet = toSet(incoming.id);

  // ê¸°ì¡´ ë°ì´í„° ì¤‘ í•˜ë‚˜ë¼ë„ ê²¹ì¹˜ë©´ "ì¤‘ë³µ"
  const isDuplicate = prev.some(item => {
    const itemSet = toSet(item.id);
    return [...incomingSet].some(v => itemSet.has(v));
  });

  if (isDuplicate) {
    return prev; // ðŸ”¥ ì¤‘ë³µì´ë©´ ë¬´ì‹œ
  }

  return [...prev, incoming];
});








setSelected(prev => {
  const incomingSet = toSet(incoming.id);

  let merged = false;

  const next = prev.map(item => {
    const itemSet = toSet(item.id);

    const hasOverlap = [...incomingSet].some(v => itemSet.has(v));
    if (!hasOverlap) return item;

    merged = true;

    const union = new Set([...itemSet, ...incomingSet]);
    const mergedStr = Array.from(union).join(', ');

    return {
      id: mergedStr,
      name: mergedStr,
    };
  });

  if (!merged) {
    next.push(incoming);
  }

  return next;
});
